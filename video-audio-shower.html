<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>VAM1 Player</title>
  <style>body{font-family:sans-serif;padding:12px;} canvas{border:1px solid #ccc;}</style>
</head>
<body>
<h2>VAM1 Player</h2>
<input type="file" id="file" accept=".vam">
<br><br>
<canvas id="canvas"></canvas>
<audio id="audio" controls></audio>

<script>
// --- Helpers ---
function readLE32(data, offset) {
  return data[offset] | (data[offset+1]<<8) | (data[offset+2]<<16) | (data[offset+3]<<24);
}
function readLE16(data, offset) {
  return data[offset] | (data[offset+1]<<8);
}

// IMA ADPCM decoder (nibble-based, 16-bit PCM output)
const IMA_INDEX_TABLE = [ -1,-1,-1,-1,2,4,6,8, -1,-1,-1,-1,2,4,6,8 ];
const IMA_STEP_TABLE = [
  7, 8, 9, 10, 11, 12, 13, 14, 16,17,19,21,23,25,28,31,
  34,37,41,45,50,55,60,66,73,80,88,97,107,118,130,143,
  157,173,190,209,230,253,279,307,337,371,408,449,494,544,598,658,
  724,796,876,963,1060,1166,1282,1411,1552,1707,1878,2066,2272,2499,2749,3024,
  3327,3660,4026,4428,4871,5358,5894,6484,7132,7845,8630,9493,10442,11487,12635,13899,
  15289,16818,18500,20350,22385,24623,27086,29794,32767
];

function imaDecodeChunk(adpcmBytes) {
  if (!adpcmBytes || adpcmBytes.length < 3) return new Int16Array(0); // empty chunk
  let predictor = adpcmBytes[0] | (adpcmBytes[1]<<8);
  let index = adpcmBytes[2];
  const out = new Int16Array((adpcmBytes.length-3)*2);
  let ptr = 0;
  for(let i=3;i<adpcmBytes.length;i++){
    let b = adpcmBytes[i];
    for(let nib=0;nib<2;nib++){
      if(ptr >= out.length) break; // safety
      let code = (nib===0)? (b&0xF) : (b>>4);
      let step = IMA_STEP_TABLE[index];
      let diffq = step>>3;
      if(code & 1) diffq += step>>2;
      if(code & 2) diffq += step>>1;
      if(code & 4) diffq += step;
      predictor += (code & 8)? -diffq : diffq;
      if(predictor>32767) predictor=32767;
      if(predictor<-32768) predictor=-32768;
      index += IMA_INDEX_TABLE[code];
      if(index<0) index=0;
      if(index>88) index=88;
      out[ptr++] = predictor;
    }
  }
  return out.subarray(0, ptr);
}

// RGB565 -> RGBA8888
function rgb565ToRgba565(hi, lo) {
  const val = (hi<<8)|lo;
  const r = ((val>>11)&0x1F)<<3;
  const g = ((val>>5)&0x3F)<<2;
  const b = (val&0x1F)<<3;
  return [r,g,b,255];
}

// --- Player ---
document.getElementById('file').onchange = async (e)=>{
  const f = e.target.files[0];
  if(!f) return;
  const data = new Uint8Array(await f.arrayBuffer());
  if(String.fromCharCode(...data.slice(0,4))!=='VAM1') { alert('Not a VAM1 file'); return; }

  const flags = data[4];
  const width = readLE16(data,5);
  const height = readLE16(data,7);
  const fps = data[9];
  const audioCodec = data[10];
  const channels = data[11];
  const sampleRate = readLE32(data,12);
  const frameCount = readLE32(data,20);

  const canvas = document.getElementById('canvas');
  canvas.width = width; canvas.height = height;
  const ctx = canvas.getContext('2d');
  const imgData = ctx.createImageData(width,height);

  let offset = 24;
  let frames = [];

  // parse frames
  for(let fidx=0;fidx<frameCount;fidx++){
    const frameSize = readLE32(data, offset); offset+=4;
    const frameBytes = data.slice(offset, offset+frameSize); offset+=frameSize;
    const audioSize = readLE32(data, offset); offset+=4;
    const audioBytes = data.slice(offset, offset+audioSize); offset+=audioSize;
    frames.push({frameBytes,audioBytes});
  }

  // decode all audio to Float32 for WebAudio
  const audioCtx = new AudioContext();
  const totalSamples = frames.reduce((a,f)=>a+imaDecodeChunk(f.audioBytes).length,0);
  const audioBuffer = audioCtx.createBuffer(channels, totalSamples/channels, sampleRate);
  let samplePos = 0;
  for(let f of frames){
    const pcm = imaDecodeChunk(f.audioBytes);
    for(let i=0;i<pcm.length;i++){
      const ch = i%channels;
      audioBuffer.getChannelData(ch)[samplePos/channels|0] = pcm[i]/32768;
    }
    samplePos += pcm.length;
  }

  const source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(audioCtx.destination);
  source.start();

  // render frames at fps
  let currentFrame = 0;
  function render(){
    if(currentFrame>=frames.length) return;
    const fBytes = frames[currentFrame].frameBytes;
    let ptr = 0;
    for(let y=0;y<height;y++){
      let x=0;
      while(x<width){
        let header = fBytes[ptr++];
        if(header & 0x80) { // repeat run
          const count = 256-header+1; // -(run-1)
          const hi = fBytes[ptr++];
          const lo = fBytes[ptr++];
          for(let k=0;k<count;k++){
            const rgba = rgb565ToRgba565(hi,lo);
            const idx = (y*width + x)*4;
            imgData.data.set(rgba, idx);
            x++;
          }
        } else { // literal
          const count = header+1;
          for(let k=0;k<count;k++){
            const hi = fBytes[ptr++];
            const lo = fBytes[ptr++];
            const rgba = rgb565ToRgba565(hi,lo);
            const idx = (y*width + x)*4;
            imgData.data.set(rgba, idx);
            x++;
          }
        }
      }
    }
    ctx.putImageData(imgData,0,0);
    currentFrame++;
    setTimeout(render, 1000/fps);
  }
  render();
};
</script>
</body>
</html>
