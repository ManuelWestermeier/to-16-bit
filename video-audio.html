<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Video+Audio → .avf (RGB565+PCM8)</title>
</head>
<body>
<h3>Video+Audio → .avf converter</h3>
<input type=file id=videoFile accept="video/*">
<br>
Width: <input type=number id=width value=160> Height: <input type=number id=height value=120>
<br>
FPS: <input type=number id=fps value=15> Audio SR: <input type=number id=audsr value=22050>
<br><br>
<button id=convert>Convert</button>
<br><br>
<a id=downloadLink" style="display:none">Download</a>
<video id=video style="display:none"></video>
<canvas id=canvas style="display:none"></canvas>
<script>
// PACKBITS encoder (byte-level)
// returns Uint8Array
function packbitsEncode(src) {
  const out = [];
  let i = 0;
  const N = src.length;
  while (i < N) {
    // look for runs
    let j = i + 1;
    while (j < N && src[j] === src[i] && (j - i) < 128) j++;
    const runLen = j - i;
    if (runLen >= 3) {
      // emit run: header = -(runLen-1) as signed byte in two's complement -> value 256 - (runLen-1)
      out.push(((256 - (runLen - 1)) & 0xFF));
      out.push(src[i]);
      i += runLen;
    } else {
      // literal block: collect up to 128 or until we see a run of >=3
      let litStart = i;
      i++;
      while (i < N) {
        // detect next run of 3
        if (i + 2 < N && src[i] === src[i+1] && src[i] === src[i+2]) break;
        if ((i - litStart) >= 128) break;
        i++;
      }
      const L = i - litStart;
      out.push((L - 1) & 0xFF); // header for literal: n (0..127) means next n+1 bytes literal
      for (let k = 0; k < L; ++k) out.push(src[litStart + k]);
    }
  }
  return new Uint8Array(out);
}

// convert RGB to RGB565 (MSB-first high byte then low byte)
function rgbTo565Bytes(r, g, b) {
  const v = ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
  return [(v >> 8) & 0xFF, v & 0xFF];
}

document.getElementById('convert').onclick = async () => {
  const file = document.getElementById('videoFile').files[0];
  if (!file) { alert('select a file'); return; }
  const width = parseInt(document.getElementById('width').value);
  const height = parseInt(document.getElementById('height').value);
  const fps = parseInt(document.getElementById('fps').value);
  const audioSR = parseInt(document.getElementById('audsr').value);

  // load video element
  const video = document.getElementById('video');
  video.src = URL.createObjectURL(file);
  await new Promise(r => video.onloadedmetadata = r);

  // prepare canvas
  const canvas = document.getElementById('canvas');
  canvas.width = width; canvas.height = height;
  const ctx = canvas.getContext('2d');

  // decode audio using AudioContext, if present
  const arrayBuffer = await file.arrayBuffer();
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  let audioPCM8 = new Uint8Array(0);
  let audioChannels = 0;
  if (file.type.startsWith('video/') || file.type.startsWith('audio/')) {
    try {
      const decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
      const ch = decoded.numberOfChannels;
      audioChannels = ch;
      // mix to mono and resample to audioSR
      // get PCM float32 for each channel
      const srcSR = decoded.sampleRate;
      const lengthIn = decoded.length;
      const totalSeconds = decoded.duration;
      const outLen = Math.floor(totalSeconds * audioSR);
      const out = new Float32Array(outLen);
      // linear resample and mix
      for (let i = 0; i < outLen; ++i) {
        const t = i / audioSR;
        const pos = t * srcSR;
        const i0 = Math.floor(pos);
        const frac = pos - i0;
        let sample = 0;
        for (let c = 0; c < ch; ++c) {
          const chBuf = decoded.getChannelData(c);
          const s0 = i0 < chBuf.length ? chBuf[i0] : 0;
          const s1 = (i0+1) < chBuf.length ? chBuf[i0+1] : 0;
          sample += (s0 * (1 - frac) + s1 * frac);
        }
        sample /= ch; // average channels -> mono
        out[i] = sample;
      }
      // convert float32 (-1..1) to unsigned 8-bit (0..255)
      audioPCM8 = new Uint8Array(outLen);
      for (let i = 0; i < outLen; ++i) {
        let v = Math.max(-1, Math.min(1, out[i]));
        let u8 = Math.round((v * 0.5 + 0.5) * 255); // map -1..1 -> 0..255
        audioPCM8[i] = u8;
      }
    } catch (e) {
      console.warn('Audio decode failed or not present:', e);
      audioPCM8 = new Uint8Array(0);
    }
  }

  // capture frames
  const frames = [];
  const interval = 1 / fps;
  let t = 0;
  // limit frames to avoid extremely large files
  const maxFrames = Math.ceil(video.duration * fps);
  video.currentTime = 0;
  for (let f = 0; f < maxFrames; ++f) {
    // seek and draw
    let target = Math.min(video.duration - 0.0001, f * interval);
    video.currentTime = target;
    await new Promise(r => video.onseeked = r);
    ctx.drawImage(video, 0, 0, width, height);
    const img = ctx.getImageData(0, 0, width, height).data;
    // convert to RGB565 bytes
    const frameBytes = new Uint8Array(width * height * 2);
    let di = 0;
    for (let px = 0; px < width * height; ++px) {
      const r = img[px * 4 + 0];
      const g = img[px * 4 + 1];
      const b = img[px * 4 + 2];
      const two = rgbTo565Bytes(r, g, b);
      frameBytes[di++] = two[0];
      frameBytes[di++] = two[1];
    }
    // packbits compress
    const comp = packbitsEncode(frameBytes);
    frames.push(comp);
    // small UI/progress
    console.log('frame', f, 'raw', frameBytes.length, 'comp', comp.length);
  }

  // build header + data
  const flags = (frames.length ? 1 : 0) | (audioPCM8.length ? 2 : 0);
  // header size variable
  const header = [];
  // magic
  header.push('A'.charCodeAt(0), 'V'.charCodeAt(0), 'F'.charCodeAt(0), '1'.charCodeAt(0));
  header.push(1); // version
  // width uint16 le
  header.push(width & 0xFF, (width >> 8) & 0xFF);
  header.push(height & 0xFF, (height >> 8) & 0xFF);
  header.push(fps & 0xFF);
  header.push(flags & 0xFF);

  const parts = [new Uint8Array(header)];

  if (audioPCM8.length) {
    // audioSampleRate (4)
    const sr = audioSR;
    parts.push(new Uint8Array([sr & 0xFF, (sr>>8)&0xFF, (sr>>16)&0xFF, (sr>>24)&0xFF]));
    // audioBits (1) audioChannels (1)
    parts.push(new Uint8Array([8, audioChannels ? audioChannels : 1]));
    // audioBytes (4)
    const ab = audioPCM8.length >>> 0;
    parts.push(new Uint8Array([ab & 0xFF, (ab>>8)&0xFF, (ab>>16)&0xFF, (ab>>24)&0xFF]));
    parts.push(audioPCM8);
  } else {
    // if no audio: still write zeros so parser is simpler (we'll write zeros for sampleRate, bits, channels, bytes)
    parts.push(new Uint8Array([0,0,0,0])); // sr
    parts.push(new Uint8Array([0,0])); // bits, channels
    parts.push(new Uint8Array([0,0,0,0])); // audioBytes
  }

  // framesCount
  const fc = frames.length >>> 0;
  parts.push(new Uint8Array([fc & 0xFF, (fc>>8)&0xFF, (fc>>16)&0xFF, (fc>>24)&0xFF]));
  // each frame: len (4) + data
  for (let i = 0; i < frames.length; ++i) {
    const c = frames[i];
    const L = c.length >>> 0;
    parts.push(new Uint8Array([L & 0xFF, (L>>8)&0xFF, (L>>16)&0xFF, (L>>24)&0xFF]));
    parts.push(c);
  }

  // Finally append audio bytes if present (we already inserted audio header and audio bytes separately; ensure audio bytes were added earlier)
  // Note: we already pushed audioPCM8 into parts earlier; so now create blob
  const blob = new Blob(parts, {type:'application/octet-stream'});
  const url = URL.createObjectURL(blob);
  const a = document.getElementById('downloadLink');
  a.href = url;
  a.download = 'out.avf';
  a.style.display = 'inline';
  a.textContent = `Download .avf (w=${width} h=${height} frames=${frames.length} audio=${audioPCM8.length} bytes)`;
  console.log('done');
};
</script>
</body>
</html>
